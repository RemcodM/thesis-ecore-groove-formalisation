\section{Advantages \& Limitations}
\label{sec:conclusion:advantages_and_limitations}

Although the approach taken by this thesis has some distinct advantages over other possible methods for proving the correctness of model transformations, there are also some limitations of the work that need to be discussed. These advantages and limitations are further discussed in this section before the work is evaluated.

As explained earlier, the transformation framework presented in \cref{chapter:transformation_framework} is considered the main result of this thesis. This framework is compelling, in that it allows to compose model transformations, which allows for creating possibly infinitely large model transformations between Ecore and GROOVE. In order to have composable model transformations, the concept of combining models and graphs is used. Within this work, it has been chosen to maintain the correctness of the transformation at each step. This correctness means that only valid or consistent models and graphs are used within each step. The use of correct models and graphs is favourable because it makes proving the correctness of the combination much more straightforward. The correctness properties of the individual models and graphs can be used to prove the correctness of the combinations.

Maintaining correctness in each step of the composition is a definite advantage to maintaining the proof of correctness. However, it also presents limitations for the transformation steps. Because of the required correctness properties, each transformation step has to be valid itself. For some transformations, this means quite significant transformation steps. For example, when introducing a new field on the type level, it is required to introduce the value for this field for all related objects on the instance level within one step. The introduction of all values at once is the only way that correctness is maintained. However, these are already quite large proofs, and they become increasingly complicated when adding inheritance. If a field is added to a supertype, a value for the field must be introduced for all instances of the supertype and its subtypes. Introducing values in this way means that an even more significant transformation step is needed to achieve such a composition. In practice, it is possible to use more substantial transformations, but it means that the complexity of proving each transformation step is increased.

The consequences of this limitation are directly visible from the library of transformations, \cref{chapter:library_of_transformations}. The transformations that introduce new fields are already quite complex, especially in their proofs. Furthermore, these transformations cannot be used on extended types because of the limitation above. Separate transformations need to be proven to allow the addition of fields to an extended type. 

Because of the limitations of the transformation framework and the limited amount of time available for this thesis, the library of transformations is quite small and incomplete. Only a selected set of transformations is presented here, which does not even cover all concepts of Ecore. On the side of Ecore, the following concepts still need to be covered:
\begin{itemize}
    \item The introduction of fields on types that are extended by other types, as discussed above.
    \item The introduction of fields typed by different container types still needs to be covered. Only one transformation shows the use of a $\type{setof}$-type in conjunction with a $\type{containment}$ property (\cref{subsec:library_of_transformations:type_level_transformations:contained_class_set_fields} and \cref{subsec:library_of_transformations:instance_level_transformations:contained_class_set_field_values}), but the other containers also need to be covered. Also, container types containing attributes still need to be covered.
    \item The concept of multiple inheritance, which is supported by Ecore and GROOVE, but not used in any transformation. Only one transformation with `single' inheritance is shown as part of \cref{subsec:library_of_transformations:type_level_transformations:regular_subclasses} and \cref{subsec:library_of_transformations:instance_level_transformations:objects_of_subtype}.
    \item Most of the different model properties (\cref{defin:formalisations:ecore_formalisation:type_models:type_model_properties}), $\type{defaultValue}$, $\type{identity}$, $\type{keyset}$, $\type{opposite}$ and $\type{readonly}$ to be precise, are not yet covered by any of the transformations. The model properties that are covered, $\type{abstract}$ and $\type{containment}$ are not yet covered in their full potential.
    \item The introduction of constants and their corresponding values is not covered yet. Since they are only used in conjunction with $\type{defaultValue}$ properties, it makes sense to cover them at the same time.
\end{itemize}
Covering all concepts of Ecore with one or more encodings in GROOVE would mean that all concepts of GROOVE are also covered. However, this way of achieving coverage means the addition of a lot more transformations, which could be its own research. Therefore, this is considered future work as described in \cref{sec:conclusion:future_work}.

A different limitation of this thesis, in general, is the focus on syntactical correctness only. No effort has been made to prove the correctness of the semantics of a model under transformation. This correctness property has been excluded on purpose, as EMF/Ecore is a quite general modelling framework in which a lot of different software models can be expressed. Therefore, it is difficult to prove something about the semantics on an abstract level. A consequence of this decision is that curious encodings are possible, which are still syntactically correct. For example, one might create an encoding that multiplies all integer values within a model with a certain number $x$, when transformed into a GROOVE graph. Then, a different transformations function can be used to convert back to a model, dividing all integer values with the same number $x$. Although this is syntactically correct, it could have enormous implications for the use within software verification, as the values of the model have changed. If this is not taken into account beforehand, the results of the software verification could still be questionable.

Although the work presented by this thesis has some limitations, the work is still considered a useful contribution. It is believed (although not proven) that it is possible to work around the limitations of the transformation framework, possibly with more substantial transformations. Moreover, the semantics of a transformation could be addressed in future research and does not invalidate the work presented here. Therefore, the work presented in this thesis should be used as a foundation, rather than a piece of work that is ready to use.